# -*- coding: utf-8 -*-
"""01 - generate data and model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19x47Bmo3Kz9Z_KK5a4CDe2EFJd0AnLTV

##Importación de librerías
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import joblib

"""##Generación de datos sintéticos"""

n_samples = 1000  # Se generan 1000 muestras
date_rng = pd.date_range(start='1/1/2010', end='31/12/2020', periods=n_samples)

data = pd.DataFrame(date_rng, columns=['datetime'])
np.random.seed(42)

data['season'] = np.random.randint(1, 5, size=n_samples)
data['holiday'] = np.random.randint(0, 2, size=n_samples)
data['workingday'] = np.random.randint(0, 2, size=n_samples)
data['weather'] = np.random.randint(1, 4, size=n_samples)

data['temp'] = np.random.randint(0, 41, size=n_samples)
data['atemp'] = data['temp'] + np.random.randint(-5, 6, size=n_samples)

data['humidity'] = np.random.randint(0, 101, size=n_samples)
data['windspeed'] = np.random.randint(0, 21, size=n_samples)
data['casual'] = np.random.randint(0, 100, size=n_samples)
data['registered'] = np.random.randint(0, 100, size=n_samples)

# Variable objetivo "count" como entero
data['count'] = data['casual'] + data['registered']

data['count'] = (10 * data['season']) + (5 * data['temp']) + (2 * data['humidity']) + (3 * data['windspeed']) + np.random.randint(-5, 6, size=n_samples)

"""##División de datos de entrenamiento y datos de prueba"""

train_data, test_data = train_test_split(data, test_size=0.2, random_state=42)

# Se guardan los datos en archivos .csv
train_data.to_csv('train_new_data.csv', index=False)
test_data.to_csv('test_new_data.csv', index=False)

print(f"Datos guardados en 'train_new_data.csv' y 'test_new_data.csv'.")

"""##Entrenamiento y guardado del modelo"""

train_data = pd.read_csv('train_new_data.csv')

# Convertir las fechas a Unix timestamp
train_data['datetime'] = pd.to_datetime(train_data['datetime'])
train_data['datetime'] = train_data['datetime'].apply(lambda x: x.timestamp())

X_train = train_data.drop("count", axis=1)  # Características
y_train = train_data["count"]  # Etiqueta

# Entrenamiento el modelo
model = LinearRegression()
model.fit(X_train, y_train)

# Guardar el modelo entrenado
joblib.dump(model, 'modelo_entrenado.pkl')
print("Modelo entrenado y guardado como 'modelo_entrenado.pkl'.")

"""##Uso del modelo nuevo y generación de predicciones"""

test_data = pd.read_csv('test_new_data.csv')

# Convertir las fechas a Unix timestamp
test_data['datetime'] = pd.to_datetime(test_data['datetime'])
test_data['datetime'] = test_data['datetime'].apply(lambda x: x.timestamp())

X_test = test_data.drop("count", axis=1)  # Características
y_test = test_data["count"]  # Etiqueta

# Cargar el modelo entrenado
loaded_model = joblib.load('modelo_entrenado.pkl')

# Realizar predicciones en los datos de prueba
predictions = loaded_model.predict(X_test)

# Mostrar las primeras predicciones junto con los valores reales
predicted_vs_real = pd.DataFrame({'Predicción': predictions, 'Valor Real': y_test})
print(predicted_vs_real.head())

"""##Visualización de datos Predicción vs. Valores reales"""

plt.figure(figsize=(10, 6))
plt.scatter(y_test, predictions, color='blue', alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], color='red', lw=2)
plt.xlabel("Valor Real")
plt.ylabel("Predicción")
plt.title("Predicciones vs Valores Reales")
plt.show()